---
id: primitive
title: 解读 JS 类型、引用及精度问题
sidebar_label: 原始数据
slug: /
---
import useBaseUrl from '@docusaurus/useBaseUrl';

## 基本类型
> 基本类型是一种既非对象也无方法的数据。所有基本类型的值都是不可改变的。<br />
> 在 JavaScript 中，共有7种基本类型：string，number，bigint，boolean，null，undefined，symbol (ECMAScript 2016新增)。

## 引用类型
> 引用类型：对象（Object）、数组（Array）、函数（Function）

## 基本类型与引用类型的区别
**基本类型**：
1. 占用空间固定，保存在栈中（当一个方法执行时，每个方法都会建立自己的内存栈，在这个方法内定义的变量将会逐个放入这块栈内存里，随着方法的执行结束，这个方法的内存栈也将自然销毁了。因此，所有在方法中定义的变量都是放在栈内存中的；栈中存储的是基础变量以及一些对象的引用变量，基础变量的值是存储在栈中，而引用变量存储在栈中的是指向堆中的数组或者对象的地址，这就是为何修改引用类型总会影响到其他指向这个地址的引用变量。）
2. 保存与复制的是值本身
3. 使用typeof检测数据的类型
4. 基本类型数据是值类型

**引用类型**：
1. 占用空间不固定，保存在堆中（当我们在程序中创建一个对象时，这个对象将被保存到运行时数据区中，以便反复利用（因为对象的创建成本通常较大），这个运行时数据区就是堆内存。堆内存中的对象不会随方法的结束而销毁，即使方法结束后，这个对象还可能被另一个引用变量所引用（方法的参数传递时很常见），则这个对象依然不会被销毁，只有当一个对象没有任何引用变量引用它时，系统的垃圾回收机制才会在核实的时候回收它。）
2. 保存与复制的是指向对象的一个指针
3. 使用instanceof检测数据类型
4. 使用new()方法构造出的对象是引用型

```javascript
var a = 100;
var b = a;
a = 200;
console.log(b); // 100 保存与复制的是值本身

// 引用类型： 对象、数组、函数、null(空指针)
// 可以扩展属性
var a = {age: 20};
var b = a;
b.age = 21;
console.log(a.age); // 21

// 利用 typeof 来区分
typeof undefined   // undefined
typeof 'abc'       // string
typeof 123         // number
typeof true        // boolean

// typeof 区分不出来引用类型 （除了函数）
typeof {}          // object
typeof []          // object
typeof null        // object
typeof console.log // function

// 用 instanceof 来区分引用类型
// 如果变量是给定引用类型（根据他们的原型链来识别）的实例，那么 instanceof 操作符就会返回 true。
console.log(person instanceof Object); // 变量 person 是 Object 吗？
console.log(colors instanceof Array);  // 变量 colors 是 Array 吗？
console.log(pattern instanceof RegExp); // 变量 pattern 是 RegExp 吗？
```

**几方面的区别举例**：
1. **动态的属性**： 定义基本类型值和引用类型值的方式是类似的。但是，当这个值保存到变量中以后，对不同类型值可以执行的操作则大相径庭。对于引用类型的值，我们可以为其添加属性和方法，也可以改变和删除其属性和方法，但是，我们不能给基本类型的值添加属性，只能给引用类型值动态地添加属性，以便将来使用。例如：
  ```javascript
  var person = new Object(); 
  person.name = "Nicholas"; 
  alert(person.name); //"Nicholas"
  ```
2. **复制变量值**： 如果从一个变量向另一个变量复制基本类型值，会在变量对象上创建一个新值，然后把该值复制到为新变量分配的位置上。
  ```javascript
  var num1 = 5;
  var num2 = num1;
  ```
  上述例子中，num1保存的值是5，当使用 num1 的值来初始化 num2 时，num2 中也保存了值 5。但 num2中的 5 与 num1 中的 5 是完全独立的，该值只是 num1 中 5 的一个副本。此后，这两个变量可以参与任何操作而不会相互影响。

  当从一个变量向另一个变量复制引用类型的值时，同样也会将存储在变量对象中的值复制一份放到为新变量分配的空间中。不同的是，这个值的副本实际上是一个指针，而这个指针指向存储在堆中的一个对象。复制操作结束后，两个变量实际上引用同一个对象。因此，改变其中一个变量，就会影响另外一个变量：例
  ```javascript
  var obj1 = new Object(); 
  var obj2 = obj1; 
  obj1.name = "Nicholas"; 
  alert(obj2.name); //"Nicholas" 
  ```

  首先，变量 obj1 保存了一个对象的新实例。然后，这个值被复制到了 obj2 中；换句话说，obj1和 obj2 都指向同一个对象。这样，当为 obj1 添加 name 属性后，可以通过 obj2 来访问这个属性，因为这两个变量引用的都是同一个对象。

3. **传递参数**：在向参数传递基本类型的值时，被传递的值会被复制给一个局部变量（即命名参数，或者用ECMAScript 的概念来说，就是 arguments 对象中的一个元素）。在向参数传递引用类型的值时，会把这个值在内存中的地址复制给一个局部变量，因此这个局部变量的变化会反映在函数的外部。
  ```javascript
  function addTen(num) { 
    num += 10; 
    return num; 
  } 

  var count = 20; 
  var result = addTen(count); 
  alert(count); //20，没有变化
  alert(result); //30
  ```
  在函数内部，参数 num 的值被加上了 10，但这一变化不会影响函数外部的 count 变量。参数num 与变量 count 互不相识，它们仅仅是具有相同的值。

  ```javascript
  function setName(obj) { 
    obj.name = "Nicholas"; 
  } 
  var person = new Object(); 
  setName(person); 
  alert(person.name); //"Nicholas" 
  ```

  为了证明对象是按值传递的，我们再看一看下面这个经过修改的例子：
  ```javascript
  function setName(obj) { 
    obj.name = "Nicholas";
    obj = new Object();
    obj.name = "Greg";
  } 
  var person = new Object(); 
  setName(person); 
  alert(person.name); //"Nicholas" 
  ```

  如果 person 是按引用传递的，那么 person 就会自动被修改为指向其 name 属性值为"Greg"的新对象。但是，当接下来再访问 person.name 时，显示的值仍然是"Nicholas"。

  这说明即使在函数内部修改了参数的值，但原始的引用仍然保持未变。实际上，当在函数内部重写 obj 时，这个变量引用的就是一个局部对象了。而这个局部对象会在函数执行完毕后立即被销毁。

## 整数和浮点数
JavaScript 内部，所有数字都是以64位浮点数形式储存，即使整数也是如此。所以，1与1.0是相同的，是同一个数。

```javascript
1 === 1.0
```
这就是说，JavaScript 语言的底层根本没有整数，所有数字都是小数（64位浮点数）。容易造成混淆的是，某些运算只有整数才能完成，此时 JavaScript 会自动把64位浮点数，转成32位整数，然后再进行运算。

[参考资料 —— 二进制位运算符 ](https://wangdoc.com/javascript/operators/bit.html)

:::note

由于浮点数不是精确的值，所以涉及小数的比较和运算要特别小心。

:::

```javascript
0.1 + 0.2 === 0.3
// false

0.3 / 0.1
// 2.9999999999999996

(0.3 - 0.2) === (0.2 - 0.1)
// false
```

## 数值精度
根据国际标准 IEEE 754，JavaScript 浮点数的64个二进制位，从最左边开始，是这样组成的。

<img alt="IEEE 754标准" src={useBaseUrl('img/210323/21032301.png')} />

* 第1位：符号位，0表示正数，1表示负数
* 第2位到第12位（共11位）：指数部分
* 第13位到第64位（共52位）：小数部分（即有效数字）

符号位决定了一个数的正负，指数部分决定了数值的大小，小数部分决定了数值的精度。

指数部分一共有11个二进制位，因此大小范围就是0到2047。IEEE 754 规定，如果指数部分的值在0到2047之间（不含两个端点），那么有效数字的第一位默认总是1，不保存在64位浮点数之中。也就是说，有效数字这时总是1.xx...xx的形式，其中xx..xx的部分保存在64位浮点数之中，最长可能为52位。因此，JavaScript 提供的有效数字最长为53个二进制位。

<img alt="IEEE 754标准公式" src={useBaseUrl('img/210323/210323115919.jpg')} />

精度位总共是 53 bit，因为用科学计数法表示，所以首位固定的 1 就没有占用空间。即公式中 (M + 1) 里的 1。另外公式里的 1023 是 2^11 的一半。小于 1023 的用来表示小数，大于 1023 的用来表示整数。指数可以控制到 2^1024 - 1，而精度最大只达到 2^53 - 1，两者相比可以得出 JavaScript 实际可以精确表示的数字其实很少。

## 二进制精度问题
> 0.1 + 0.2 为什么等于 0.30000000000000004 以及 JavaScript 中最大安全数是如何来的。

### 十进制小数转二进制小数
拿 173.8125 举例如何将之转化为二进制小数。

1. 针对整数部分 173，采取 ***除 2 取余，逆序排列***;

  ```
  173 / 2 = 86         1
  86 / 2 = 43          0     ↑
  43 / 2 = 21          1     |
  21 / 2 = 10          1     | 逆序排列
  10 / 2 = 5           0     |
  5 / 2 = 2            1     |
  2 / 2 = 1            0
  1 / 2 = 0            1
  ```
  得整数部分的二进制为 `10101101` 。

2. 针对小数部分 0.8125，采用 ***乘 2 取整，顺序排列***;

  ```
  0.8125 * 2 = 1.625   1     |
  0.625 * 2 = 1.25     1     | 顺序排列
  0.25 * 2 = 0.5       0     |
  0.5 * 2 = 1          1     ↓
  ```
  得小数部分的二进制为 `1101` 。

3. 将前面两部的结果相加，结果为 ***10101101.1101***;

:::danger

小心，二进制小数丢失了精度！

:::

### 0.1 十进制转二进制
根据上面的知识，将十进制小数 0.1 转为二进制：

```
0.1 * 2 = 0.2
0.2 * 2 = 0.4 // 注意这里
0.4 * 2 = 0.8
0.8 * 2 = 1.6
0.6 * 2 = 1.2
0.2 * 2 = 0.4 // 注意这里，循环开始
0.4 * 2 = 0.8
0.8 * 2 = 1.6
0.6 * 2 = 1.2
...
```

可以发现有限十进制小数 `0.1` 却转化成了无限二进制小数 `0.00011001100...` ，可以看到精度在转化过程中丢失了！

能被转化为有限二进制小数的十进制小数的最后一位必然以 `5` 结尾(因为只有 `0.5 * 2` 才能变为整数)。所以十进制中一位小数 `0.1 ~ 0.9` 当中除了 `0.5` 之外的值在转化成二进制的过程中都丢失了精度。

### 解决 0.1 + 0.2
> 先乘以 10 相加，运算完后除以 10

### JavaScript 的最大安全数是如何来的
根据双精度浮点数的构成，精度位数是 53 bit。安全数的意思是在 -2^53 ~ 2^53 内的整数(不包括边界)与唯一的双精度浮点数互相对应。举个例子比较好理解：

```javascript
Math.pow(2, 53) === Math.pow(2, 53) + 1 // true
```

Math.pow(2, 53) 竟然与 Math.pow(2, 53) + 1 相等！这是因为 Math.pow(2, 53) + 1 已经超过了尾数的精度限制(53 bit)，在这个例子中 Math.pow(2, 53) 和 Math.pow(2, 53) + 1 对应了同一个双精度浮点数。所以 Math.pow(2, 53) 就不是安全数了。

最大的安全数为 Math.pow(2, 53) - 1，即 9007199254740991。

## 业务中碰到的精度问题以及解决方案
了解 JavaScript 精度问题对我们业务有什么帮助呢？举个业务场景：比如有个订单号后端 Java 同学定义的是 long 类型，但是当这个订单号转换成 JavaScript 的 Number 类型时候精度会丢失了，那没有以上知识铺垫那就理解不了精度为什么会丢失。

解决方案大致有以下几种：
1. 针对大数的整数可以考虑使用 `bigint` 类型。
2. 引用第三方库 `bignumber.js`，原理是把所有数字当作字符串，重新实现了计算逻辑，缺点是性能比原生的差很多。