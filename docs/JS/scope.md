---
id: scope
title: 作用域、词法作用域、执行上下文
sidebar_label: 作用域、执行上下文等
---

许多开发人员经常混淆 ***作用域*** 和 ***执行上下文*** 的概念，误认为它们是相同的概念，但事实并非如此。我们知道 JavaScript 属于解释型语言， JavaScript 的执行分为：**解释** 和 **执行** 两个阶段，这两个阶段所做的事并不一样。

## JS 属于解释型语言
* 对于常见编译型语言（例如：Java）来说，编译步骤分为：`词法分析->语法分析->语义检查->代码优化和字节生成`。
* 对于解释型语言（例如：JavaScript ）来说，通过 **词法分析和语法分析** 得到 **语法树** 后，就可以开始 **解释执行** 了。

**解释阶段：**
1. 词法分析
2. 语法分析
3. 预编译（并非完全的顺序执行）

**执行阶段：**
1. 创建执行上下文
2. 执行函数代码
3. 垃圾回收

### 词法分析
词法分析是将字符流(char stream)转换为记号流(token stream)，就像英文句子一个个单词独立翻译，举例：

```javascript
// 字符流代码
var result = testNum1 - testNum2;


// 词法分析
NAME "result"  
EQUALS  
NAME "testNum1"  
MINUS  
NAME "testNum2"  
SEMICOLON 
```

### 语法分析
将上一步生成的 token 数据根据语法规则生成对应的 -***“抽象语法树”(Abstract Syntax Tree, AST)***。在这个过程中 JS 会对全部的脚本代码进行解析，通过 **Javascript引擎** 检查你的代码是否存在错误，如果有格式错误就会抛出一个错误。如果成功构建完 AST，接着就通过 AST 生成字节码，也就生成了计算机可执行的代码，该过程叫做代码生成。

点击链接输入 `var a = 2` ,查看AST树结构：[在线生成 AST 树](https://astexplorer.net/) 

抽象语法树转为一组机器指令，用来创建一个叫作 a 的变量(包括分配内存等)，并将值 2 储存在 a 中。

### 预编译（并非完全的顺序执行）
“function函数” 是一等公民！编译阶段，会把定义时的函数优先执行，也会把所有var变量创建，默认值为undefined，以提高程序的执行效率！

在预编译期预编译期需要注意下面几个问题：
1. 预编译首先是全局预编译，函数体在未调用时不进行预编译
2. 只有 var 和 function 声明会提升
3. 注意是在**所在作用域内提升**，不会扩展到其他作用域
4. 预编译后顺序执行

> 在解释过程中，JavaScript引擎是严格按着作用域机制（scope）来执行的。JavaScript语法采用的是词法作用域（lexcical scope），也就是说JavaScript的变量和函数作用域是在定义时决定的，而不是执行时决定的，由于词法作用域取决于源代码结构，所以 JavaScript解释器只需要通过静态分析就能确定每个变量、函数的作用域，这种作用域也称为静态作用域（static scope）。

### 创建执行上下文
我们先来了解一下js的运行环境，运行环境主要由三种：

1. 全局环境（ js 代码加载完毕后，进入到预编译也就是进入到全局环境）
2. 函数环境（函数调用的时候，进入到该函数环境，不同的函数，函数环境不同）
3. eval 环境（不建议使用，存在安全、性能问题）

每进入到一个不同的运行环境都会创建 ***一个相应的执行上下文（execution context）***，那么在一段 js 程序中一般都会创建多个执行上下文，js 引擎会以 ***栈的数据结构*** 对这些执行进行处理，形成 ***函数调用栈（call stack）*** ，栈底永远是 ***全局执行上下文（global execution context）***，栈顶则永远时 ***当前的执行上下文***。

### 【扩展】词法作用域
> 上方预编译中有书写

所谓的词法作用域就是**在你写代码时将变量和块作用域写在哪里来决定，也就是词法作用域是静态的作用域，在你书写代码时就确定了**。

请看以下代码：
```javascript
function fn1(x) {
	var y = x + 4;
	function fn2(z) {
		console.log(x, y, z);
	}
	fn2(y * 5);
}
fn1(6); // 6 10 50


/*
* 全局作用域，有一个标识符：fn1
* fn1所创建的作用域，有三个标识符：x、y、fn2
* fn2所创建的作用域，有一个标识符：z
*/
```

作用域是由期代码写在哪里决定的，并且是逐级包含的。

### 【区别】作用域、执行上下文
JavaScript 解释阶段便会确定**作用域规则**，因此作用域在函数定义时就已经确定了，而不是在函数调用时确定，但是执行上下文是函数执行之前创建的。执行上下文最明显的就是 `this` 的指向是执行时确定的。而作用域访问的变量是编写代码的结构确定的。

作用域和执行上下文之间最大的区别是：**执行上下文在运行时确定，随时可能改变；作用域在定义时就确定，并且不会改变**。

一个作用域下可能包含若干个上下文环境。有可能从来没有过上下文环境（函数从来就没有被调用过）；有可能有过，现在函数被调用完毕后，上下文环境被销毁了；有可能同时存在一个或多个（闭包）。**同一个作用域下，不同的调用会产生不同的执行上下文环境，继而产生不同的变量的值**。

## 作用域
> 作用域就是一套规则，用于确定在何处以及如何查找变量（标识符）的规则。

在这句话中读到一个关键点 **查找变量（标识符）**，那么就从查找变量说起。

```javascript
// 代码一
function foo() {
	var a = 'man';
	console.log(a); // "man"
}
foo();
// 在 foo 函数执行的时候，输出一个 a 变量，那么这个 a 变量是哪里来的嘞？
// 有看到函数第一行有定义 a 变量的代码 var a = 'man' 。



// 代码二
var b = 'programmer';
function foo() {
	console.log(b); // "programmer"
}
foo();
// 在输出b的时候，自己函数内部没有找到变量b，那么就在外层的全局中查找，
// 找到了就停止查找并输出了。
```

通俗的讲，作用域就是查找变量的地方。
+ 在某函数中找到该变量，就可以说在该**函数作用域**中找到了该变量；
+ 在全局中找到该变量，就可以说在**全局作用域**中找到了该变量！

### (1) 函数作用域
### (2) 全局作用域
### (3) 块级作用域
块级作用域可通过新增命令let和const声明，所声明的变量在指定块的作用域外无法被访问。块级作用域在如下情况被创建：
1. 在一个函数内部
2. 在一个代码块（由一对花括号包裹）内部

let 声明的语法与 var 的语法一致。你基本上可以用 let 来代替 var 进行变量声明，但会将变量的作用域限制在当前代码块中。块级作用域有以下几个特点：
* 声明变量不会提升到代码块顶部
* 禁止重复声明
* 循环中的绑定块作用域的妙用


## 作用域链
我们在 **查找变量** 的时候，先在 **函数作用域中查找** ，没有找到，再去 **全局作用域中** 查找，有一个往外层查找的过程。我们好像是顺着一条链条从下往上查找变量，这条链条，我们就称之为 **作用域链**。

## 作用域嵌套
在还没有接触到ES6的let、const之前，只有函数作用域和全局作用域，函数作用域肯定是在全局作用域里面的，而函数作用域中又可以继续嵌套函数作用域。

```javascript
var d =4;             // 全局作用域
function fn3() {      // 作用域3
  var c = 3;
  function fn2() {    // 作用域2
    var b = 2;
    function fn1() {  // 作用域1
      var a = 1;
    }
  }
}
```

## 作用域中变量（标识符）的查找规则
JavaScript是有编译过程的，也就是说 `var name = 'man'` 这段代码，其实这是有两个动作的：

* 编译器在当前作用域中声明一个变量name
* 运行时引擎在作用域中查找该变量，找到了name变量并为其赋值

```javascript
// 例：
console.log(name); // undefined
var name = 'man'; 
```

在代码执行之前从上到下的进行编译，当遇到某个用 var 声明的变量的时候，先检查在当前作用域下是否存在该变量。
+ 如果 **存在** ，则**忽略声明**；
+ 如果**不存在**，则在**当前作用域中声明该变量**；

上面的这段简单的代码包含两种查找类型：输出变量的值的时候的查找类型是RHS，找到变量为其赋值的查找类型是LHS。

+ **LHS**：变量出现在赋值操作的 **左侧** 时进行LHS查询；
+ **RHS**：变量出现在赋值操作的 **右侧** 时进行RHS查询，RHS就是取到它的源值；

在作用域链都没找到，报错：`ReferenceError: 某变量 is not defined`